---
title: "Graph clustering"
author: 
  - name: "Teun van den Brand"
    email: "t.vd.brand@nki.nl"
    affiliation: "Netherlands Cancer Institute"
date: '`r format(Sys.time(), "%d/%m/%Y")`'
output: 
  html_document:
    theme: united
    highlight: pygments
    fig_caption: yes
    code_folding: hide
    df_print: kable
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
bibliography: /DATA/users/t.vd.brand/bibliography/articles.bibtex
knit: |
  # Redirect output to HTML folder
  (function(inputFile, encoding) {
    outputFile <- gsub("Rmd$", "html", basename(inputFile))
    rmarkdown::render(
      input = inputFile,
      encoding = encoding,
      output_file = here::here("html", outputFile)
    )
  })
---

## Setup {.tabset}

<!-- little HTML script to do indentation of the table of contents -->
<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 10, 'padding-left': 0});
      });

    });
</script>

```{css, echo = FALSE}
div.sourceCode {
  overflow-x: hidden;
}
```

### Load packages

```{r stfu, include = FALSE}
# No, I do *not* want your start-up messages, thank you very much
library <- function(...) {
  suppressPackageStartupMessages(base::library(...))
}
```


```{r load_packages}
library(SingleCellExperiment)
library(igraph)
library(bluster)
library(e1071)
library(xgboost)
library(Biostrings)
library(data.table)

library(here)
library(ggplot2)
library(ggh4x)
library(colorspace)
library(scales)
```

### Load data

```{r load_data}
exp_file <- here("rds", "06_LSI_experiment.rds")
exp <- readRDS(exp_file)
```

### Setup Aesthetics

```{r setup_aes}
mycolour <- "#000000FF" # Opaque Black

theme_set(theme_gray())
theme_update(text = element_text(colour = mycolour),
             line = element_line(colour = mycolour),
             aspect.ratio = 1,
             axis.line  = element_line(colour = mycolour),
             axis.ticks = element_line(colour = mycolour),
             axis.text  = element_text(colour = mycolour),
             legend.key = element_blank(),
             legend.background = element_rect(colour = NA, fill = NA),
             panel.background = element_blank(),
             panel.grid.major = element_line(colour = "grey95"),
             panel.grid.minor = element_blank(),
             plot.background  = element_blank(),
             strip.background = element_blank(),
             strip.text = element_text(colour = mycolour))
CYRUP <- c("#fed500", "#009bef", "#ff5c49", "#949494", "#D8D8D8")
rm(mycolour)

sample_colours <- c(brewer_pal(palette = "Set1")(9), "black")
div_colours <- c("#0065b2", "#2399de", "#67cdfe", "#f5f5f5", "#fcb09d", "#ed6855", 
"#be2a21")

umap_xy_scales <- function(name = "UMAP", breaks = NULL, ...) {
  list(
    scale_x_continuous(paste(name, 1), breaks = breaks, ...),
    scale_y_continuous(paste(name, 2), breaks = breaks, ...),
    coord_equal(),
    theme(aspect.ratio = NULL)
  )
}

my_legend <- guide_legend(
  override.aes = list(size = 2, alpha = 1)
)

scale_colour_samples <- function(
  name   = "Samples", 
  values = sample_colours, 
  guide  = my_legend,
  ...
) {
  scale_colour_manual(
    name   = name,
    values = values,
    guide  = guide,
    ...
  )
}

label_clusters <- function(
    var, ..., colour = "black", 
    show.legend = FALSE, na.rm = TRUE
) {
  stat_centroid(
    funx = median, funy = median,
    aes(label = {{ var }}, group = {{ var }}),
    geom = "text", ..., colour = colour,
    show.legend = show.legend, na.rm = na.rm
  )
}
```

## Aim

First, we'll cluster the timeseries data. Then, we'll learn the correct labels for the KO data. This makes sure that we don't base our clusters on the KO data.

## Context

Here is the UMAP with the timepoints / samples.

```{r}
umap <- reducedDim(exp, "UMAP")
umap <- data.frame(
  x = umap[, 1],
  y = umap[, 2],
  sample = forcats::fct_collapse(exp$sample, WT = c("E14 WT", "HM1 WT"))
)

ggplot(umap, aes(x, y, colour = sample)) +
  geom_point(size = 0.5) +
  umap_xy_scales() +
  scale_colour_samples()
```

## Make graph

We'll make a shared nearest neighbour graph of the timeseries data.

```{r}
is_timeseries <- exp$batch != "KOs"
pca   <- reducedDim(exp, "LSI-integrated-corrected")[, 2:30]
graph <- makeSNNGraph(pca, k = 15)
```

## Leiden Clustering

### Do clustering

```{r}
set.seed(20220414)

clust_leiden <- orig <- cluster_leiden(graph, resolution_parameter = 0.1)

clust_leiden <- clust_leiden$membership

df <- cbind(umap, leiden = NA_character_)
df$leiden <- LETTERS[clust_leiden]

ggplot(df, aes(x, y, colour = leiden)) +
  geom_point(size = 0.5) +
  label_clusters(leiden) +
  umap_xy_scales() +
  # scale_colour_manual(
  #   values = colours_leiden
  # ) +
  guides(colour = my_legend)
```

### Silhouette

```{r}
sil <- approxSilhouette(pca, clusters = clust_leiden)
sil <- as.data.frame(sil)
sil <- cbind(umap, sil, cluster = clust_leiden)

ggplot(sil, aes(x = LETTERS[cluster], y = width, colour = LETTERS[other])) +
  ggbeeswarm::geom_quasirandom() +
  labs(
    x = "Cluster",
    y = "Silhouette Width",
    colour = "Closest other cluster"
  )
```

```{r}
ggplot(sil, aes(x, y, colour = width)) +
  geom_point() +
  
  scale_colour_viridis_c(limits = c(NA, 0.5), oob = oob_squish,
                         name = "Silhouette Width") +
  umap_xy_scales()
```

### Purity

```{r}
purity <- neighborPurity(pca, clust_leiden)

purity <- as.data.frame(purity)
purity <- cbind(umap, purity, cluster = clust_leiden)

ggplot(purity, aes(LETTERS[cluster], purity, colour = LETTERS[maximum])) +
  ggbeeswarm::geom_quasirandom() +
  labs(x = "Cluster", y = "Purity", colour = "Most neighbours")
```

```{r}
ggplot(purity, aes(x, y, colour = purity)) +
  geom_point() +
  umap_xy_scales() +
  scale_colour_viridis_c(limits = c(0, 1))
```

## Tidying up

We see that cluster J is very small (1 cell) and cluster H has a bad silhouette. For these cells, we'll assign them to the closest other cluster available.

### Reassignment

```{r}
cluster <- ifelse(clust_leiden %in% 8, sil$other, clust_leiden)
cluster <- ifelse(cluster %in% 10, 4, cluster)

cluster <- match(cluster, sort(unique(cluster)))

cluster <- dplyr::case_when(
  cluster == 1 ~ 4,
  cluster == 2 ~ 1,
  cluster == 3 ~ 6,
  cluster == 4 ~ 5,
  cluster == 5 ~ 3,
  cluster == 6 ~ 2,
  cluster == 7 ~ 7,
  cluster == 8 ~ 8
)
```

### Formatting

```{r}
# Custom
colours <- brewer_pal(palette = "Set1")(9)
colours[6] <- "#fed500"
colours <- colours[c(6, 3, 7, 4, 5, 2, 8, 1)]

# Austria
colours <- c(
  "#A40000", # red
  "#00b7a7", # turquoise
  "#007e2f", # green
  "#ffcd12", # yellow
  "#b86092", # pink
  "#16317d", # blue
  "#721b3e", # purple
  "#999999"  # grey
)

# D3
colours <- c(
  "#d62728", # red
  "#bcbd22", # yellow
  "#2ca02c", # green
  "#e377c2", # pink
  "#9467bd", # purple
  "#1f77b4", # blue
  "#17becf", # turquoise
  "#8c564b"  # grey
)

colours <- c(
  "#e41a1c", # red
  "#fed500", # yellow
  "#4daf4a", # green
  "#984EA3", # purple
  "#17becf",
  # "#F781BF", # pink
  "#377EB8", # blue
  "#FF7F00", # turquoise
  "#A65628"  # grey
)


cluster_data <- DataFrame(
  cluster    = LETTERS[cluster],
  silhouette = sil$width,
  purity     = purity$purity
)
metadata(cluster_data) <- list(colours = colours)
```

```{r}
df <- cbind(umap, as.data.frame(cluster_data))

ggplot(df, aes(x, y, colour = cluster)) +
  geom_point(size = 0.5) +
  scale_colour_manual(
    values = colours
  ) +
  umap_xy_scales()
```

#### Sample highlights {.tabset}

```{r}
label_layer <- label_clusters(cluster_data$cluster)

samples <- exp$sample
samples <- split(seq_along(samples), samples)

lowlit <- ggplot(df, aes(x, y, colour = cluster)) +
  geom_point(
    aes(
      colour = stage(
        start       = cluster,
        after_scale = lighten(desaturate(colour, 0.5), 0.5)
      )
    ),
    size = 0.5
  ) +
  umap_xy_scales() +
  scale_colour_manual(
    values = colours,
    guide = my_legend
  )

plots <- lapply(setNames(nm = names(samples)), function(i) {
  lowlit + 
    geom_point(
      data = ~ .x[samples[[i]], ],
      size = 0.5
    ) +
    label_layer
})
```

```{r, results = 'asis', message = FALSE, warning=FALSE}
for (i in names(plots)) {
  cat(paste0("\n\n##### Sample ", i, "\n"))
  print(plots[[i]])
}
```

#### Proportions {.tabset}

```{r}
setDT(df)
df <- df[, .(.N), by = c("sample", "cluster")]
df[, prop := N / sum(N), by = "sample"]

ggplot(df, aes(x = prop, y = sample, fill = cluster)) +
  geom_col(width = 2 / (1 + sqrt(5))) +
  geom_text(
    aes(label = ifelse(prop > 0.05, percent(prop, 1), ""),
        group = cluster, 
        colour = stage(cluster, after_scale = darken(colour, 0.5))),
    position = position_stack(vjust = 0.5),
    size = 3, show.legend = FALSE
  ) +
  scale_fill_manual(
    aesthetics = c("fill", "colour"),
    values = colours
  ) +
  scale_x_continuous(
    expand = c(0, 0),
    name   = "Proportion",
    breaks = breaks_width(0.2) 
  ) +
  labs(y = "Sample")
```

## Save experiment

```{r}
exp$clusters <- cluster_data

saveRDS(exp, exp_file)
```


## References

<div id="refs"></div>

## Session Info

```{r session_info, include=TRUE, echo=FALSE, results = "asis"}
pkgs <- loadedNamespaces()
libTvdB::format_sessioninfo_html(pkgs)
```
